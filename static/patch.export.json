{
  "desc": {
    "parameters": [
      {
        "type": "ParameterTypeNumber",
        "index": 0,
        "name": "pitch",
        "paramId": "pitch",
        "minimum": 20,
        "maximum": 20000,
        "exponent": 1,
        "steps": 5,
        "initialValue": 220,
        "isEnum": false,
        "enumValues": [],
        "displayName": "",
        "unit": "",
        "order": 0,
        "displayorder": "-",
        "sendinit": true,
        "initialized": true,
        "debug": false,
        "saveable": true,
        "transmittable": true,
        "visible": true,
        "signalIndex": null,
        "ioType": "IOTypeUndefined",
        "serialId": "param_s08",
        "constrainFunc": "param_01_value_constrain"
      },
      {
        "type": "ParameterTypeNumber",
        "index": 1,
        "name": "source",
        "paramId": "source",
        "minimum": 0,
        "maximum": 3,
        "exponent": 1,
        "steps": 4,
        "initialValue": 1,
        "isEnum": true,
        "enumValues": [
          "off",
          "cycle",
          "saw",
          "rect"
        ],
        "displayName": "",
        "unit": "",
        "order": 0,
        "displayorder": "-",
        "sendinit": true,
        "initialized": true,
        "debug": false,
        "saveable": true,
        "transmittable": true,
        "visible": true,
        "signalIndex": null,
        "ioType": "IOTypeUndefined",
        "serialId": "param_s04",
        "constrainFunc": "param_02_value_constrain"
      },
      {
        "type": "ParameterTypeNumber",
        "index": 2,
        "name": "gain",
        "paramId": "gain",
        "minimum": 0,
        "maximum": 1,
        "exponent": 1,
        "steps": 0,
        "initialValue": 0.5,
        "isEnum": false,
        "enumValues": [],
        "displayName": "",
        "unit": "",
        "order": 0,
        "displayorder": "-",
        "sendinit": 0,
        "initialized": true,
        "debug": false,
        "saveable": true,
        "transmittable": true,
        "visible": true,
        "signalIndex": null,
        "ioType": "IOTypeUndefined",
        "serialId": "paramtilde_a1_s04"
      },
      {
        "type": "ParameterTypeSignal",
        "index": 3,
        "name": "gain",
        "paramId": "/signals/gain",
        "minimum": 0,
        "maximum": 1,
        "exponent": 1,
        "steps": 0,
        "initialValue": 0,
        "isEnum": false,
        "enumValues": [],
        "displayName": "",
        "unit": "",
        "order": "",
        "displayorder": "-",
        "sendinit": "",
        "initialized": false,
        "debug": false,
        "saveable": false,
        "transmittable": false,
        "visible": false,
        "signalIndex": 0,
        "ioType": "IOTypeInput"
      }
    ],
    "numParameters": 4,
    "numSignalInParameters": 1,
    "numSignalOutParameters": 0,
    "numInputChannels": 0,
    "numOutputChannels": 1,
    "numMidiInputPorts": 0,
    "numMidiOutputPorts": 0,
    "externalDataRefs": [
      {
        "id": "snd",
        "file": "jongly.aif",
        "type": "Float32Buffer",
        "tag": "buffer"
      }
    ],
    "patcherSerial": 0,
    "inports": [
      {
        "tag": "gooblies",
        "meta": {
          "desc": "message report"
        }
      },
      {
        "tag": "grooveplay",
        "meta": ""
      }
    ],
    "outports": [
      {
        "tag": "rng",
        "meta": ""
      }
    ],
    "inlets": [],
    "outlets": [
      {
        "type": "signal",
        "index": 1,
        "tag": "out1",
        "meta": ""
      }
    ],
    "paramConversion": {
      "applyStepsToNormalizedParameterValue": "function applyStepsToNormalizedParameterValue(normalizedValue, steps) {\n    if (steps == 1) {\n        if (normalizedValue > 0) {\n            normalizedValue = 1.;\n        }\n    } else {\n        let oneStep = 1. / (steps - 1);\n        let numberOfSteps = rnbo_fround(normalizedValue / oneStep * 1 / 1) * 1;\n        normalizedValue = numberOfSteps * oneStep;\n    }\n\n    return normalizedValue;\n}",
      "convertToNormalizedParameterValue": "function convertToNormalizedParameterValue(index, value) {\n    switch (index) {\n    case 2:\n        {\n            value = (value < 0 ? 0 : (value > 1 ? 1 : value));\n            let normalizedValue = (value - 0) / (1 - 0);\n            return normalizedValue;\n        }\n    case 1:\n        {\n            value = (value < 0 ? 0 : (value > 3 ? 3 : value));\n            let normalizedValue = (value - 0) / (3 - 0);\n\n            {\n                normalizedValue = this.applyStepsToNormalizedParameterValue(normalizedValue, 4);\n            }\n\n            return normalizedValue;\n        }\n    case 0:\n        {\n            value = (value < 20 ? 20 : (value > 20000 ? 20000 : value));\n            let normalizedValue = (value - 20) / (20000 - 20);\n\n            {\n                normalizedValue = this.applyStepsToNormalizedParameterValue(normalizedValue, 5);\n            }\n\n            return normalizedValue;\n        }\n    default:\n        return value;\n    }\n}",
      "convertFromNormalizedParameterValue": "function convertFromNormalizedParameterValue(index, value) {\n    value = (value < 0 ? 0 : (value > 1 ? 1 : value));\n\n    switch (index) {\n    case 2:\n        {\n            value = (value < 0 ? 0 : (value > 1 ? 1 : value));\n\n            {\n                return 0 + value * (1 - 0);\n            }\n        }\n    case 1:\n        {\n            value = (value < 0 ? 0 : (value > 1 ? 1 : value));\n\n            {\n                value = this.applyStepsToNormalizedParameterValue(value, 4);\n            }\n\n            {\n                return 0 + value * (3 - 0);\n            }\n        }\n    case 0:\n        {\n            value = (value < 0 ? 0 : (value > 1 ? 1 : value));\n\n            {\n                value = this.applyStepsToNormalizedParameterValue(value, 5);\n            }\n\n            {\n                return 20 + value * (20000 - 20);\n            }\n        }\n    default:\n        return value;\n    }\n}",
      "getNumParameters": "function getNumParameters() {\n    return 4;\n}",
      "constrainParameterValue": "function constrainParameterValue(index, value) {\n    var v = value;\n\n    switch (index) {\n    case 0:\n        {\n            v = (v > 20000 ? 20000 : (v < 20 ? 20 : v));\n\n            {\n                const oneStep = 19980 / 4;\n                const oneStepInv = (oneStep != 0 ? 1 / oneStep : 0);\n                const numberOfSteps = rnbo_fround(v * oneStepInv * 1 / 1) * 1;\n                v = numberOfSteps * oneStep;\n            }\n\n            return v;\n        }\n    case 1:\n        {\n            v = (v > 3 ? 3 : (v < 0 ? 0 : v));\n\n            {\n                const oneStep = 3 / 3;\n                const oneStepInv = (oneStep != 0 ? 1 / oneStep : 0);\n                const numberOfSteps = rnbo_fround(v * oneStepInv * 1 / 1) * 1;\n                v = numberOfSteps * oneStep;\n            }\n\n            return v;\n        }\n    default:\n        return value;\n    }\n}",
      "subpatches": {},
      "isPolyphonic": false
    },
    "presetid": "rnbo",
    "meta": {
      "architecture": "x64",
      "maxversion": "8.5.3",
      "rnboversion": "1.2.0-jby-rnbo-subdiv"
    }
  },
  "src": [
    {
      "code": "class RNBOPatcher {\n\tconstructor() {\n\t\tthis.dspexpr_01_in1 = 0;\n\t\tthis.dspexpr_01_in2 = 0;\n\t\tthis.selector_01_onoff = 1;\n\t\tthis.dspexpr_02_in1 = 0;\n\t\tthis.dspexpr_02_in2 = 0.5;\n\t\tthis.listindex_01_input = [];\n\t\tthis.listindex_01_index = [0];\n\t\tthis.param_01_value = 220;\n\t\tthis.cycle_tilde_01_frequency = 220;\n\t\tthis.cycle_tilde_01_phase_offset = 0;\n\t\tthis.paramtilde_01_value = 0.5;\n\t\tthis.paramtilde_01_value_setter(this.paramtilde_01_value);\n\t\tthis.saw_tilde_01_frequency = 220;\n\t\tthis.saw_tilde_01_syncPhase = 0;\n\t\tthis.param_02_value = 1;\n\t\tthis.rect_tilde_01_frequency = 220;\n\t\tthis.rect_tilde_01_pulsewidth = 0.5;\n\t\tthis.rect_tilde_01_syncPhase = 0;\n\t\tthis.data_01_sizeout = 0;\n\t\tthis.data_01_size = 0;\n\t\tthis.data_01_sizems = 0;\n\t\tthis.data_01_normalize = 0.995;\n\t\tthis.data_01_channels = 1;\n\t\tthis.groove_01_rate_auto = 1;\n\t\tthis.groove_01_begin = 0;\n\t\tthis.groove_01_end = -1;\n\t\tthis.groove_01_loop = 0;\n\t\tthis.groove_01_crossfade = 0;\n\t\tthis.phasor_01_freq = 1;\n\t\tthis.random_01_limit = 100;\n\t\tthis.random_01_limit_setter(this.random_01_limit);\n\t\tthis.random_01_seed = 0;\n\t\tthis.whatobject_01_triggermode = 2;\n\t\tthis.whatobject_01_syncupdate = 0;\n\t\tthis.whatobject_01_matches = [0];\n\t\tthis.whatobject_01_input_list = [];\n\t\tthis.numberobj_01_value = 0;\n\t\tthis.numberobj_01_value_setter(this.numberobj_01_value);\n\t\tthis._currentTime = 0;\n\t\tthis.audioProcessSampleCount = 0;\n\t\tthis.sampleOffsetIntoNextAudioBuffer = 0;\n\t\tthis.zeroBuffer = 0;\n\t\tthis.dummyBuffer = 0;\n\t\tthis.signals = new Array(5);\n\t\tthis.didAllocateSignals = 0;\n\t\tthis.vs = 0;\n\t\tthis.maxvs = 0;\n\t\tthis.sr = 44100;\n\t\tthis.invsr = 0.00002267573696;\n\t\tthis.param_01_lastValue = 0;\n\t\tthis.cycle_tilde_01_buffer = 0;\n\t\tthis.cycle_tilde_01_wrap = 0;\n\t\tthis.cycle_tilde_01_phasei = 0;\n\t\tthis.cycle_tilde_01_f2i = 0;\n\t\tthis.cycle_tilde_01_ph_currentPhase = 0;\n\t\tthis.cycle_tilde_01_ph_conv = 0;\n\t\tthis.cycle_tilde_01_setupDone = false;\n\t\tthis.paramtilde_01_lastIndex = 0;\n\t\tthis.paramtilde_01_sigbuf = 0;\n\t\tthis.paramtilde_01_setupDone = false;\n\t\tthis.saw_tilde_01_t = 0;\n\t\tthis.saw_tilde_01_lastSyncPhase = 0;\n\t\tthis.saw_tilde_01_lastSyncDiff = 0;\n\t\tthis.saw_tilde_01_didSync = false;\n\t\tthis.saw_tilde_01_dcblocker_xm1 = 0;\n\t\tthis.saw_tilde_01_dcblocker_ym1 = 0;\n\t\tthis.saw_tilde_01_setupDone = false;\n\t\tthis.param_02_lastValue = 0;\n\t\tthis.rect_tilde_01_xHistory = 0;\n\t\tthis.rect_tilde_01_yHistory = 0;\n\t\tthis.rect_tilde_01_t = 0;\n\t\tthis.rect_tilde_01_lastSyncPhase = 0;\n\t\tthis.rect_tilde_01_lastSyncDiff = 0;\n\t\tthis.rect_tilde_01_didSync = false;\n\t\tthis.data_01_buffer = 0;\n\t\tthis.data_01_sizemode = 0;\n\t\tthis.data_01_setupDone = false;\n\t\tthis.groove_01_buffer = 0;\n\t\tthis.groove_01_readIndex = 0;\n\t\tthis.groove_01_playStatus = 0;\n\t\tthis.groove_01_changeIncomingInSamples = 0;\n\t\tthis.groove_01_incomingChange = 2;\n\t\tthis.groove_01_crossfadeInSamples = 0;\n\t\tthis.groove_01_setupDone = false;\n\t\tthis.edge_01_currentState = 0;\n\t\tthis.edge_01_setupDone = false;\n\t\tthis.phasor_01_sigbuf = 0;\n\t\tthis.phasor_01_lastLockedPhase = 0;\n\t\tthis.phasor_01_conv = 0;\n\t\tthis.phasor_01_ph_currentPhase = 0;\n\t\tthis.phasor_01_ph_conv = 0;\n\t\tthis.phasor_01_setupDone = false;\n\t\tthis.random_01_nz_state = new BigUint64Array(4);\n\t\tthis.whatobject_01_detector_prev1 = 0;\n\t\tthis.whatobject_01_detector_prev2 = 0;\n\t\tthis.whatobject_01_detector_sahTolerance = 0.1;\n\t\tthis.whatobject_01_detector_matchedIndex = 0;\n\t\tthis.whatobject_01_detector_matchesReg = [0];\n\t\tthis.whatobject_01_detector_reversal = false;\n\t\tthis.whatobject_01_detector_prevReversal = false;\n\t\tthis.numberobj_01_currentFormat = 6;\n\t\tthis.numberobj_01_lastValue = 0;\n\t\tthis.globaltransport_tempo = 0;\n\t\tthis.globaltransport_tempoNeedsReset = false;\n\t\tthis.globaltransport_lastTempo = 120;\n\t\tthis.globaltransport_state = 0;\n\t\tthis.globaltransport_stateNeedsReset = false;\n\t\tthis.globaltransport_lastState = 0;\n\t\tthis.globaltransport_beatTimeChanges = [0,0];\n\t\tthis.globaltransport_timeSignatureChanges = [4,4,0];\n\t\tthis.globaltransport_notify = false;\n\t\tthis.globaltransport_setupDone = false;\n\t\tthis.stackprotect_count = 0;\n\t\tthis.RNBODefaultSinus = 0;\n\t\tthis.snd = 0;\n\t\tthis._voiceIndex = 0;\n\t\tthis._noteNumber = 0;\n\t\tthis.isMuted = 1;\n\t\tthis.paramInitIndices = [];\n\t\tthis.paramInitOrder = [];\n\t} // end constructor\n\tlistquicksort(arr, sortindices, l, h, ascending) {\n\t    if (l < h) {\n\t        var p = (this.listpartition(arr, sortindices, l, h, ascending));\n\t        this.listquicksort(arr, sortindices, l, p - 1, ascending);\n\t        this.listquicksort(arr, sortindices, p + 1, h, ascending);\n\t    }\n\t}\n\tlistpartition(arr, sortindices, l, h, ascending) {\n\t    var x = arr[h];\n\t    var i = (l - 1);\n\t\n\t    for (var j = (l); j <= h - 1; j++) {\n\t        var asc = ((ascending) && arr[j] <= x);\n\t        var desc = ((!(ascending)) && arr[j] >= x);\n\t\n\t        if ((asc) || (desc)) {\n\t            i++;\n\t            this.listswapelements(arr, i, j);\n\t            this.listswapelements(sortindices, i, j);\n\t        }\n\t    }\n\t\n\t    i++;\n\t    this.listswapelements(arr, i, h);\n\t    this.listswapelements(sortindices, i, h);\n\t    return i;\n\t}\n\tlistswapelements(arr, a, b) {\n\t    var tmp = arr[a];\n\t    arr[a] = arr[b];\n\t    arr[b] = tmp;\n\t}\n\tsamplerate() {\n\t    return this.sr;\n\t}\n\tmstosamps(ms) {\n\t    return ms * this.sr * 0.001;\n\t}\n\tvectorsize() {\n\t    return this.vs;\n\t}\n\tminimum(x, y) {\n\t    return (y < x ? y : x);\n\t}\n\tmaximum(x, y) {\n\t    return (x < y ? y : x);\n\t}\n\tvoice() {\n\t    return this._voiceIndex;\n\t}\n\trandom(low, high) {\n\t    let range = high - low;\n\t    return rand01() * range + low;\n\t}\n\tcurrenttime() {\n\t    return this._currentTime;\n\t}\n\ttempo() {\n\t    return this.getTopLevelPatcher().globaltransport_getTempo();\n\t}\n\tmstobeats(ms) {\n\t    return ms * this.tempo() * 0.008 / 480;\n\t}\n\tsampstoms(samps) {\n\t    return samps * 1000 / this.sr;\n\t}\n\tparam_01_value_set(v) {\n\t    v = this.param_01_value_constrain(v);\n\t    this.param_01_value = v;\n\t    this.sendParameter(0, false);\n\t\n\t    if (this.param_01_value != this.param_01_lastValue) {\n\t        this.getEngine().presetTouched();\n\t        this.param_01_lastValue = this.param_01_value;\n\t    }\n\t\n\t    this.rect_tilde_01_frequency_set(v);\n\t    this.saw_tilde_01_frequency_set(v);\n\t    this.cycle_tilde_01_frequency_set(v);\n\t}\n\tparam_02_value_set(v) {\n\t    v = this.param_02_value_constrain(v);\n\t    this.param_02_value = v;\n\t    this.sendParameter(1, false);\n\t\n\t    if (this.param_02_value != this.param_02_lastValue) {\n\t        this.getEngine().presetTouched();\n\t        this.param_02_lastValue = this.param_02_value;\n\t    }\n\t\n\t    this.selector_01_onoff_set(v);\n\t}\n\tparamtilde_01_value_set(v) {\n\t    this.paramtilde_01_value_setter(v);\n\t    v = this.paramtilde_01_value;\n\t    this.sendParameter(2, false);\n\t    var k = (this.sampleOffsetIntoNextAudioBuffer);\n\t\n\t    if ((this.paramtilde_01_sigbuf)) {\n\t        for (var i = (this.paramtilde_01_lastIndex); i < k; i++) {\n\t            this.paramtilde_01_sigbuf[i] = v;\n\t            this.paramtilde_01_lastIndex = k;\n\t        }\n\t    }\n\t}\n\tinport_01_value_bang_bang() {\n\t    this.inport_01_out_bang_bang();\n\t}\n\tinport_01_value_number_set(v) {\n\t    this.inport_01_out_number_set(v);\n\t}\n\tinport_01_value_list_set(v) {\n\t    this.inport_01_out_list_set(v);\n\t}\n\tinport_02_value_bang_bang() {\n\t    this.inport_02_out_bang_bang();\n\t}\n\tinport_02_value_number_set(v) {\n\t    this.inport_02_out_number_set(v);\n\t}\n\tinport_02_value_list_set(v) {\n\t    this.inport_02_out_list_set(v);\n\t}\n\tedge_01_onout_bang() {\n\t    this.random_01_trigger_bang();\n\t}\n\tedge_01_offout_bang() {}\n\tnumberobj_01_valin_set(v) {\n\t    this.numberobj_01_value_set(v);\n\t}\n\tnumberobj_01_format_set(v) {\n\t    this.numberobj_01_currentFormat = rnbo_trunc((v > 6 ? 6 : (v < 0 ? 0 : v)));\n\t}\n\tbutton_01_bangin_bang() {\n\t    this.button_01_bangval_bang();\n\t}\n\tgetNumMidiInputPorts() {\n\t    return 0;\n\t}\n\tprocessMidiEvent(time, port, data, length) {}\n\tgetNumMidiOutputPorts() {\n\t    return 0;\n\t}\n\tprocess(inputs, numInputs, outputs, numOutputs, n) {\n\t    this.vs = n;\n\t    this.updateTime(this.getEngine().getCurrentTime());\n\t    var gain = (numInputs >= 1 && inputs[0] ? inputs[0] : this.zeroBuffer);\n\t    var out1 = (numOutputs >= 1 && outputs[0] ? outputs[0] : this.dummyBuffer);\n\t\n\t    this.cycle_tilde_01_perform(\n\t        this.cycle_tilde_01_frequency,\n\t        this.cycle_tilde_01_phase_offset,\n\t        this.signals[0],\n\t        this.dummyBuffer,\n\t        n\n\t    );\n\t\n\t    this.paramtilde_01_perform(gain, this.signals[1], n);\n\t\n\t    this.saw_tilde_01_perform(\n\t        this.saw_tilde_01_frequency,\n\t        this.saw_tilde_01_syncPhase,\n\t        this.signals[2],\n\t        this.dummyBuffer,\n\t        n\n\t    );\n\t\n\t    this.rect_tilde_01_perform(\n\t        this.rect_tilde_01_frequency,\n\t        this.rect_tilde_01_pulsewidth,\n\t        this.rect_tilde_01_syncPhase,\n\t        this.signals[3],\n\t        this.dummyBuffer,\n\t        n\n\t    );\n\t\n\t    this.selector_01_perform(\n\t        this.selector_01_onoff,\n\t        this.signals[0],\n\t        this.signals[2],\n\t        this.signals[3],\n\t        this.signals[4],\n\t        n\n\t    );\n\t\n\t    this.dspexpr_02_perform(this.signals[4], this.dspexpr_02_in2, this.signals[3], n);\n\t    this.dspexpr_01_perform(this.signals[3], this.signals[1], this.dummyBuffer, n);\n\t\n\t    this.groove_01_perform(\n\t        this.groove_01_rate_auto,\n\t        this.groove_01_begin,\n\t        this.groove_01_end,\n\t        out1,\n\t        this.dummyBuffer,\n\t        n\n\t    );\n\t\n\t    this.phasor_01_perform(this.phasor_01_freq, this.signals[1], n);\n\t    this.whatobject_01_perform(this.signals[1], this.signals[3], this.dummyBuffer, n);\n\t    this.edge_01_perform(this.signals[3], n);\n\t    this.stackprotect_perform(n);\n\t    this.globaltransport_advance();\n\t    this.audioProcessSampleCount += this.vs;\n\t}\n\tprepareToProcess(sampleRate, maxBlockSize, force) {\n\t    if (this.maxvs < maxBlockSize || !this.didAllocateSignals) {\n\t        var i;\n\t\n\t        for (i = 0; i < 5; i++) {\n\t            this.signals[i] = resizeSignal(this.signals[i], this.maxvs, maxBlockSize);\n\t        }\n\t\n\t        this.paramtilde_01_sigbuf = resizeSignal(this.paramtilde_01_sigbuf, this.maxvs, maxBlockSize);\n\t        this.phasor_01_sigbuf = resizeSignal(this.phasor_01_sigbuf, this.maxvs, maxBlockSize);\n\t        this.globaltransport_tempo = resizeSignal(this.globaltransport_tempo, this.maxvs, maxBlockSize);\n\t        this.globaltransport_state = resizeSignal(this.globaltransport_state, this.maxvs, maxBlockSize);\n\t        this.zeroBuffer = resizeSignal(this.zeroBuffer, this.maxvs, maxBlockSize);\n\t        this.dummyBuffer = resizeSignal(this.dummyBuffer, this.maxvs, maxBlockSize);\n\t        this.didAllocateSignals = true;\n\t    }\n\t\n\t    var sampleRateChanged = sampleRate != this.sr;\n\t    var maxvsChanged = maxBlockSize != this.maxvs;\n\t    var forceDSPSetup = sampleRateChanged || maxvsChanged || force;\n\t\n\t    if (sampleRateChanged || maxvsChanged) {\n\t        this.vs = maxBlockSize;\n\t        this.maxvs = maxBlockSize;\n\t        this.sr = sampleRate;\n\t        this.invsr = 1 / sampleRate;\n\t    }\n\t\n\t    this.cycle_tilde_01_dspsetup(forceDSPSetup);\n\t    this.paramtilde_01_dspsetup(forceDSPSetup);\n\t    this.saw_tilde_01_dspsetup(forceDSPSetup);\n\t    this.data_01_dspsetup(forceDSPSetup);\n\t    this.groove_01_dspsetup(forceDSPSetup);\n\t    this.phasor_01_dspsetup(forceDSPSetup);\n\t    this.edge_01_dspsetup(forceDSPSetup);\n\t    this.globaltransport_dspsetup(forceDSPSetup);\n\t\n\t    if (sampleRateChanged)\n\t        this.onSampleRateChanged(sampleRate);\n\t}\n\tmsToSamps(ms, sampleRate) {\n\t    return ms * sampleRate * 0.001;\n\t}\n\tsampsToMs(samps) {\n\t    return samps * (this.invsr * 1000);\n\t}\n\tgetMaxBlockSize() {\n\t    return this.maxvs;\n\t}\n\tgetSampleRate() {\n\t    return this.sr;\n\t}\n\thasFixedVectorSize() {\n\t    return false;\n\t}\n\tgetNumInputChannels() {\n\t    return 0;\n\t}\n\tgetNumOutputChannels() {\n\t    return 1;\n\t}\n\tsetProbingTarget(id) {\n\t    switch (id) {\n\t    default:\n\t        this.setProbingIndex(-1);\n\t        break;\n\t    }\n\t}\n\tsetProbingIndex(index) {}\n\tgetProbingChannels(outletId) {\n\t    RNBO_UNUSED(outletId);\n\t    return 0;\n\t}\n\tgetDataRef(index) {\n\t    switch (index) {\n\t    case 0:\n\t        return addressOf(this.RNBODefaultSinus);\n\t        break;\n\t    case 1:\n\t        return addressOf(this.snd);\n\t        break;\n\t    default:\n\t        return null;\n\t    }\n\t}\n\tgetNumDataRefs() {\n\t    return 2;\n\t}\n\tfillRNBODefaultSinus(ref) {\n\t    var buffer;\n\t    buffer = new Float64Buffer(ref);\n\t    let bufsize = buffer.getSize();\n\t\n\t    for (let i = 0; i < bufsize; i++) {\n\t        buffer[i] = rnbo_cos(i * 3.14159265358979323846 * 2. / bufsize);\n\t    }\n\t}\n\tfillDataRef(index, ref) {\n\t    switch (index) {\n\t    case 0:\n\t        this.fillRNBODefaultSinus(ref);\n\t        break;\n\t    }\n\t}\n\tzeroDataRef(ref) {\n\t    ref.setZero();\n\t}\n\tprocessDataViewUpdate(index, time) {\n\t    this.updateTime(time);\n\t\n\t    if (index == 0) {\n\t        this.cycle_tilde_01_buffer = new Float64Buffer(this.RNBODefaultSinus);\n\t        this.cycle_tilde_01_bufferUpdated();\n\t    }\n\t\n\t    if (index == 1) {\n\t        this.data_01_buffer = new Float32Buffer(this.snd);\n\t        this.data_01_bufferUpdated();\n\t        this.groove_01_buffer = new Float32Buffer(this.snd);\n\t    }\n\t}\n\tallocateDataRefs() {\n\t    this.cycle_tilde_01_buffer.requestSize(16384, 1);\n\t    this.cycle_tilde_01_buffer.setSampleRate(this.sr);\n\t    this.cycle_tilde_01_buffer = this.cycle_tilde_01_buffer.allocateIfNeeded();\n\t\n\t    if (this.RNBODefaultSinus.hasRequestedSize()) {\n\t        if (this.RNBODefaultSinus.wantsFill())\n\t            this.fillRNBODefaultSinus(this.RNBODefaultSinus);\n\t\n\t        this.getEngine().sendDataRefUpdated(0);\n\t    }\n\t\n\t    this.data_01_buffer = this.data_01_buffer.allocateIfNeeded();\n\t    this.groove_01_buffer = this.groove_01_buffer.allocateIfNeeded();\n\t\n\t    if (this.snd.hasRequestedSize()) {\n\t        if (this.snd.wantsFill())\n\t            this.zeroDataRef(this.snd);\n\t\n\t        this.getEngine().sendDataRefUpdated(1);\n\t    }\n\t}\n\tinitialize() {\n\t    this.RNBODefaultSinus = initDataRef(\"RNBODefaultSinus\", true, null, \"buffer~\");\n\t    this.snd = initDataRef(\"snd\", false, \"jongly.aif\", \"buffer\");\n\t    this.assign_defaults();\n\t    this.setState();\n\t    this.RNBODefaultSinus.setIndex(0);\n\t    this.cycle_tilde_01_buffer = new Float64Buffer(this.RNBODefaultSinus);\n\t    this.snd.setIndex(1);\n\t    this.data_01_buffer = new Float32Buffer(this.snd);\n\t    this.groove_01_buffer = new Float32Buffer(this.snd);\n\t    this.initializeObjects();\n\t    this.allocateDataRefs();\n\t    this.startup();\n\t}\n\tinitializeObjects() {\n\t    this.data_01_init();\n\t    this.random_01_nz_init();\n\t    this.whatobject_01_detector_init();\n\t    this.numberobj_01_init();\n\t}\n\tgetIsMuted() {\n\t    return this.isMuted;\n\t}\n\tsetIsMuted(v) {\n\t    this.isMuted = v;\n\t}\n\tgetPatcherSerial() {\n\t    return 0;\n\t}\n\tgetState(state) {}\n\tsetState() {}\n\tgetPreset(preset) {\n\t    preset[\"__presetid\"] = \"rnbo\";\n\t    this.param_01_getPresetValue(getSubState(preset, \"pitch\"));\n\t    this.param_02_getPresetValue(getSubState(preset, \"source\"));\n\t}\n\tsetPreset(time, preset) {\n\t    this.updateTime(time);\n\t    this.param_01_setPresetValue(getSubState(preset, \"pitch\"));\n\t    this.param_02_setPresetValue(getSubState(preset, \"source\"));\n\t}\n\tprocessTempoEvent(time, tempo) {\n\t    this.updateTime(time);\n\t\n\t    if (this.globaltransport_setTempo(tempo, false))\n\t        {}\n\t}\n\tprocessTransportEvent(time, state) {\n\t    this.updateTime(time);\n\t\n\t    if (this.globaltransport_setState(state, false))\n\t        {}\n\t}\n\tprocessBeatTimeEvent(time, beattime) {\n\t    this.updateTime(time);\n\t\n\t    if (this.globaltransport_setBeatTime(beattime, false))\n\t        {}\n\t}\n\tonSampleRateChanged(samplerate) {}\n\tprocessTimeSignatureEvent(time, numerator, denominator) {\n\t    this.updateTime(time);\n\t\n\t    if (this.globaltransport_setTimeSignature(numerator, denominator, false))\n\t        {}\n\t}\n\tsetParameterValue(index, v, time) {\n\t    this.updateTime(time);\n\t\n\t    switch (index) {\n\t    case 0:\n\t        this.param_01_value_set(v);\n\t        break;\n\t    case 1:\n\t        this.param_02_value_set(v);\n\t        break;\n\t    case 2:\n\t        this.paramtilde_01_value_set(v);\n\t        break;\n\t    case 3:\n\t        // namedAudioIn: gain\n\t        break;\n\t    }\n\t}\n\tprocessParameterEvent(index, value, time) {\n\t    this.setParameterValue(index, value, time);\n\t}\n\tprocessNormalizedParameterEvent(index, value, time) {\n\t    this.setParameterValueNormalized(index, value, time);\n\t}\n\tgetParameterValue(index) {\n\t    switch (index) {\n\t    case 0:\n\t        return this.param_01_value;\n\t    case 1:\n\t        return this.param_02_value;\n\t    case 2:\n\t        return this.paramtilde_01_value;\n\t    case 3:\n\t        // namedAudioIn: gain\n\t        return 0;\n\t    default:\n\t        return 0;\n\t    }\n\t}\n\tgetNumSignalInParameters() {\n\t    return 1;\n\t}\n\tgetNumSignalOutParameters() {\n\t    return 0;\n\t}\n\tgetNumParameters() {\n\t    return 4;\n\t}\n\tgetParameterName(index) {\n\t    switch (index) {\n\t    case 0:\n\t        return \"pitch\";\n\t    case 1:\n\t        return \"source\";\n\t    case 2:\n\t        return \"gain\";\n\t    case 3:\n\t        return \"gain\";\n\t    default:\n\t        return \"bogus\";\n\t    }\n\t}\n\tgetParameterId(index) {\n\t    switch (index) {\n\t    case 0:\n\t        return \"pitch\";\n\t    case 1:\n\t        return \"source\";\n\t    case 2:\n\t        return \"gain\";\n\t    case 3:\n\t        return \"/signals/gain\";\n\t    default:\n\t        return \"bogus\";\n\t    }\n\t}\n\tgetParameterInfo(index, info) {\n\t    {\n\t        switch (index) {\n\t        case 0:\n\t            info.type = ParameterTypeNumber;\n\t            info.initialValue = 220;\n\t            info.min = 20;\n\t            info.max = 20000;\n\t            info.exponent = 1;\n\t            info.steps = 5;\n\t            info.debug = false;\n\t            info.saveable = true;\n\t            info.transmittable = true;\n\t            info.initialized = true;\n\t            info.visible = true;\n\t            info.displayName = \"\";\n\t            info.unit = \"\";\n\t            info.ioType = IOTypeUndefined;\n\t            info.signalIndex = INVALID_INDEX;\n\t            break;\n\t        case 1:\n\t            info.type = ParameterTypeNumber;\n\t            info.initialValue = 1;\n\t            info.min = 0;\n\t            info.max = 3;\n\t            info.exponent = 1;\n\t            info.steps = 4;\n\t            var eVal1 = [\"off\", \"cycle\", \"saw\", \"rect\"];\n\t            info.enumValues = eVal1;\n\t            info.debug = false;\n\t            info.saveable = true;\n\t            info.transmittable = true;\n\t            info.initialized = true;\n\t            info.visible = true;\n\t            info.displayName = \"\";\n\t            info.unit = \"\";\n\t            info.ioType = IOTypeUndefined;\n\t            info.signalIndex = INVALID_INDEX;\n\t            break;\n\t        case 2:\n\t            info.type = ParameterTypeNumber;\n\t            info.initialValue = 0.5;\n\t            info.min = 0;\n\t            info.max = 1;\n\t            info.exponent = 1;\n\t            info.steps = 0;\n\t            info.debug = false;\n\t            info.saveable = true;\n\t            info.transmittable = true;\n\t            info.initialized = true;\n\t            info.visible = true;\n\t            info.displayName = \"\";\n\t            info.unit = \"\";\n\t            info.ioType = IOTypeUndefined;\n\t            info.signalIndex = INVALID_INDEX;\n\t            break;\n\t        case 3:\n\t            info.type = ParameterTypeSignal;\n\t            info.initialValue = 0;\n\t            info.min = 0;\n\t            info.max = 1;\n\t            info.exponent = 1;\n\t            info.steps = 0;\n\t            info.debug = false;\n\t            info.saveable = false;\n\t            info.transmittable = false;\n\t            info.initialized = false;\n\t            info.visible = false;\n\t            info.displayName = \"\";\n\t            info.unit = \"\";\n\t            info.ioType = IOTypeInput;\n\t            info.signalIndex = 0;\n\t            break;\n\t        }\n\t    }\n\t}\n\tsendParameter(index, ignoreValue) {\n\t    this.getEngine().notifyParameterValueChanged(index, (ignoreValue ? 0 : this.getParameterValue(index)), ignoreValue);\n\t}\n\tapplyStepsToNormalizedParameterValue(normalizedValue, steps) {\n\t    if (steps == 1) {\n\t        if (normalizedValue > 0) {\n\t            normalizedValue = 1.;\n\t        }\n\t    } else {\n\t        let oneStep = 1. / (steps - 1);\n\t        let numberOfSteps = rnbo_fround(normalizedValue / oneStep * 1 / 1) * 1;\n\t        normalizedValue = numberOfSteps * oneStep;\n\t    }\n\t\n\t    return normalizedValue;\n\t}\n\tconvertToNormalizedParameterValue(index, value) {\n\t    switch (index) {\n\t    case 2:\n\t        {\n\t            value = (value < 0 ? 0 : (value > 1 ? 1 : value));\n\t            let normalizedValue = (value - 0) / (1 - 0);\n\t            return normalizedValue;\n\t        }\n\t    case 1:\n\t        {\n\t            value = (value < 0 ? 0 : (value > 3 ? 3 : value));\n\t            let normalizedValue = (value - 0) / (3 - 0);\n\t\n\t            {\n\t                normalizedValue = this.applyStepsToNormalizedParameterValue(normalizedValue, 4);\n\t            }\n\t\n\t            return normalizedValue;\n\t        }\n\t    case 0:\n\t        {\n\t            value = (value < 20 ? 20 : (value > 20000 ? 20000 : value));\n\t            let normalizedValue = (value - 20) / (20000 - 20);\n\t\n\t            {\n\t                normalizedValue = this.applyStepsToNormalizedParameterValue(normalizedValue, 5);\n\t            }\n\t\n\t            return normalizedValue;\n\t        }\n\t    default:\n\t        return value;\n\t    }\n\t}\n\tconvertFromNormalizedParameterValue(index, value) {\n\t    value = (value < 0 ? 0 : (value > 1 ? 1 : value));\n\t\n\t    switch (index) {\n\t    case 2:\n\t        {\n\t            value = (value < 0 ? 0 : (value > 1 ? 1 : value));\n\t\n\t            {\n\t                return 0 + value * (1 - 0);\n\t            }\n\t        }\n\t    case 1:\n\t        {\n\t            value = (value < 0 ? 0 : (value > 1 ? 1 : value));\n\t\n\t            {\n\t                value = this.applyStepsToNormalizedParameterValue(value, 4);\n\t            }\n\t\n\t            {\n\t                return 0 + value * (3 - 0);\n\t            }\n\t        }\n\t    case 0:\n\t        {\n\t            value = (value < 0 ? 0 : (value > 1 ? 1 : value));\n\t\n\t            {\n\t                value = this.applyStepsToNormalizedParameterValue(value, 5);\n\t            }\n\t\n\t            {\n\t                return 20 + value * (20000 - 20);\n\t            }\n\t        }\n\t    default:\n\t        return value;\n\t    }\n\t}\n\tconstrainParameterValue(index, value) {\n\t    switch (index) {\n\t    case 0:\n\t        return this.param_01_value_constrain(value);\n\t    case 1:\n\t        return this.param_02_value_constrain(value);\n\t    default:\n\t        return value;\n\t    }\n\t}\n\tscheduleParamInit(index, order) {\n\t    this.paramInitIndices.push(index);\n\t    this.paramInitOrder.push(order);\n\t}\n\tprocessParamInitEvents() {\n\t    this.listquicksort(\n\t        this.paramInitOrder,\n\t        this.paramInitIndices,\n\t        0,\n\t        (this.paramInitOrder.length - 1),\n\t        true\n\t    );\n\t\n\t    for (var i = 0; i < this.paramInitOrder.length; i++) {\n\t        this.getEngine().scheduleParameterChange(\n\t            this.paramInitIndices[i],\n\t            this.getParameterValue(this.paramInitIndices[i]),\n\t            0\n\t        );\n\t    }\n\t}\n\tprocessClockEvent(time, index, hasValue, value) {\n\t    RNBO_UNUSED(value);\n\t    RNBO_UNUSED(hasValue);\n\t    this.updateTime(time);\n\t\n\t    switch (index) {\n\t    case -611950441:\n\t        this.edge_01_onout_bang();\n\t        break;\n\t    case -1584063977:\n\t        this.edge_01_offout_bang();\n\t        break;\n\t    }\n\t}\n\tprocessOutletAtCurrentTime(sender, index, value) {}\n\tprocessOutletEvent(sender, index, value, time) {\n\t    this.updateTime(time);\n\t    this.processOutletAtCurrentTime(sender, index, value);\n\t}\n\tsendOutlet(index, value) {\n\t    this.getEngine().sendOutlet(this, index, value);\n\t}\n\tprocessNumMessage(tag, objectId, time, payload) {\n\t    this.updateTime(time);\n\t\n\t    switch (tag) {\n\t    case TAG(\"gooblies\"):\n\t        this.inport_01_value_number_set(payload);\n\t        break;\n\t    case TAG(\"grooveplay\"):\n\t        this.inport_02_value_number_set(payload);\n\t        break;\n\t    case TAG(\"valin\"):\n\t        if (TAG(\"number_obj-44\") == objectId)\n\t            this.numberobj_01_valin_set(payload);\n\t\n\t        break;\n\t    case TAG(\"format\"):\n\t        if (TAG(\"number_obj-44\") == objectId)\n\t            this.numberobj_01_format_set(payload);\n\t\n\t        break;\n\t    }\n\t}\n\tprocessListMessage(tag, objectId, time, payload) {\n\t    RNBO_UNUSED(objectId);\n\t    this.updateTime(time);\n\t\n\t    switch (tag) {\n\t    case TAG(\"gooblies\"):\n\t        this.inport_01_value_list_set(payload);\n\t        break;\n\t    case TAG(\"grooveplay\"):\n\t        this.inport_02_value_list_set(payload);\n\t        break;\n\t    }\n\t}\n\tprocessBangMessage(tag, objectId, time) {\n\t    this.updateTime(time);\n\t\n\t    switch (tag) {\n\t    case TAG(\"gooblies\"):\n\t        this.inport_01_value_bang_bang();\n\t        break;\n\t    case TAG(\"grooveplay\"):\n\t        this.inport_02_value_bang_bang();\n\t        break;\n\t    case TAG(\"bangin\"):\n\t        if (TAG(\"button_obj-41\") == objectId)\n\t            this.button_01_bangin_bang();\n\t\n\t        break;\n\t    }\n\t}\n\tresolveTag(tag) {\n\t    switch (tag) {\n\t    case TAG(\"rng\"):\n\t        return \"rng\";\n\t    case TAG(\"\"):\n\t        return \"\";\n\t    case TAG(\"valout\"):\n\t        return \"valout\";\n\t    case TAG(\"number_obj-44\"):\n\t        return \"number_obj-44\";\n\t    case TAG(\"setup\"):\n\t        return \"setup\";\n\t    case TAG(\"bangout\"):\n\t        return \"bangout\";\n\t    case TAG(\"button_obj-41\"):\n\t        return \"button_obj-41\";\n\t    case TAG(\"gooblies\"):\n\t        return \"gooblies\";\n\t    case TAG(\"grooveplay\"):\n\t        return \"grooveplay\";\n\t    case TAG(\"valin\"):\n\t        return \"valin\";\n\t    case TAG(\"format\"):\n\t        return \"format\";\n\t    case TAG(\"bangin\"):\n\t        return \"bangin\";\n\t    }\n\t\n\t    return \"\";\n\t}\n\tgetNumMessages() {\n\t    return 3;\n\t}\n\tgetMessageInfo(index) {\n\t    switch (index) {\n\t    case 0:\n\t        var r0 = {\n\t            \"tag\": \"rng\",\n\t            \"type\": Outport\n\t        };\n\t\n\t        return r0;\n\t    case 1:\n\t        var r1 = {\n\t            \"tag\": \"gooblies\",\n\t            \"type\": Inport\n\t        };\n\t\n\t        return r1;\n\t    case 2:\n\t        var r2 = {\n\t            \"tag\": \"grooveplay\",\n\t            \"type\": Inport\n\t        };\n\t\n\t        return r2;\n\t    }\n\t\n\t    return NullMessageInfo;\n\t}\n\tstartup() {\n\t    this.updateTime(this.getEngine().getCurrentTime());\n\t\n\t    {\n\t        this.scheduleParamInit(0, 0);\n\t    }\n\t\n\t    {\n\t        this.scheduleParamInit(1, 0);\n\t    }\n\t\n\t    this.processParamInitEvents();\n\t}\n\tparam_01_value_constrain(v) {\n\t    v = (v > 20000 ? 20000 : (v < 20 ? 20 : v));\n\t\n\t    {\n\t        const oneStep = 19980 / 4;\n\t        const oneStepInv = (oneStep != 0 ? 1 / oneStep : 0);\n\t        const numberOfSteps = rnbo_fround(v * oneStepInv * 1 / 1) * 1;\n\t        v = numberOfSteps * oneStep;\n\t    }\n\t\n\t    return v;\n\t}\n\trect_tilde_01_frequency_set(v) {\n\t    this.rect_tilde_01_frequency = v;\n\t}\n\tsaw_tilde_01_frequency_set(v) {\n\t    this.saw_tilde_01_frequency = v;\n\t}\n\tcycle_tilde_01_frequency_set(v) {\n\t    this.cycle_tilde_01_frequency = v;\n\t}\n\tparam_02_value_constrain(v) {\n\t    v = (v > 3 ? 3 : (v < 0 ? 0 : v));\n\t\n\t    {\n\t        const oneStep = 3 / 3;\n\t        const oneStepInv = (oneStep != 0 ? 1 / oneStep : 0);\n\t        const numberOfSteps = rnbo_fround(v * oneStepInv * 1 / 1) * 1;\n\t        v = numberOfSteps * oneStep;\n\t    }\n\t\n\t    return v;\n\t}\n\tselector_01_onoff_set(v) {\n\t    this.selector_01_onoff = v;\n\t}\n\tlistindex_01_out2_set(v) {}\n\tlistindex_01_out1_set(v) {\n\t    this.rect_tilde_01_frequency_set(v);\n\t    this.saw_tilde_01_frequency_set(v);\n\t    this.cycle_tilde_01_frequency_set(v);\n\t}\n\tlistindex_01_input_bang() {\n\t    var v = this.listindex_01_input;\n\t    var result = jsCreateListCopy(v);\n\t\n\t    if (this.listindex_01_index.length > 0 && this.listindex_01_index[0] < v.length && this.listindex_01_index[0] >= 0) {\n\t        var nth = v[this.listindex_01_index[0]];\n\t\n\t        if (this.listindex_01_index.length == 1)\n\t            result.splice(this.listindex_01_index[0], 1);\n\t        else\n\t            result.splice(this.listindex_01_index[0], 1, this.listindex_01_index[1]);\n\t\n\t        this.listindex_01_out2_set(result);\n\t        this.listindex_01_out1_set(nth);\n\t    } else if ((this.listindex_01_input.length))\n\t        this.listindex_01_out2_set(v);\n\t}\n\tinport_01_out_bang_bang() {\n\t    this.listindex_01_input_bang();\n\t}\n\tlistindex_01_input_set(v) {\n\t    this.listindex_01_input = jsCreateListCopy(v);\n\t    var result = jsCreateListCopy(v);\n\t\n\t    if (this.listindex_01_index.length > 0 && this.listindex_01_index[0] < v.length && this.listindex_01_index[0] >= 0) {\n\t        var nth = v[this.listindex_01_index[0]];\n\t\n\t        if (this.listindex_01_index.length == 1)\n\t            result.splice(this.listindex_01_index[0], 1);\n\t        else\n\t            result.splice(this.listindex_01_index[0], 1, this.listindex_01_index[1]);\n\t\n\t        this.listindex_01_out2_set(result);\n\t        this.listindex_01_out1_set(nth);\n\t    } else if ((this.listindex_01_input.length))\n\t        this.listindex_01_out2_set(v);\n\t}\n\tinport_01_out_number_set(v) {\n\t    {\n\t        let converted = [v];\n\t        this.listindex_01_input_set(converted);\n\t    }\n\t}\n\tinport_01_out_list_set(v) {\n\t    this.listindex_01_input_set(v);\n\t}\n\tgroove_01_rate_bang_bang() {\n\t    this.groove_01_changeIncomingInSamples = this.sampleOffsetIntoNextAudioBuffer + 1;\n\t    this.groove_01_incomingChange = 1;\n\t}\n\ttrigger_01_out1_bang() {\n\t    this.groove_01_rate_bang_bang();\n\t}\n\ttrigger_01_input_bang_bang() {\n\t    this.trigger_01_out1_bang();\n\t}\n\tinport_02_out_bang_bang() {\n\t    this.trigger_01_input_bang_bang();\n\t}\n\ttrigger_01_input_number_set(v) {\n\t    this.trigger_01_out1_bang();\n\t}\n\tinport_02_out_number_set(v) {\n\t    this.trigger_01_input_number_set(v);\n\t}\n\ttrigger_01_input_list_set(v) {\n\t    this.trigger_01_out1_bang();\n\t}\n\tinport_02_out_list_set(v) {\n\t    this.trigger_01_input_list_set(v);\n\t}\n\tnumberobj_01_output_set(v) {}\n\tnumberobj_01_value_set(v) {\n\t    this.numberobj_01_value_setter(v);\n\t    v = this.numberobj_01_value;\n\t    let localvalue = v;\n\t\n\t    if (this.numberobj_01_currentFormat != 6) {\n\t        localvalue = rnbo_trunc(localvalue);\n\t    }\n\t\n\t    this.getEngine().sendNumMessage(TAG(\"valout\"), TAG(\"number_obj-44\"), localvalue, this._currentTime);\n\t    this.numberobj_01_output_set(localvalue);\n\t}\n\toutport_01_input_number_set(v) {\n\t    this.getEngine().sendNumMessage(TAG(\"rng\"), TAG(\"\"), v, this._currentTime);\n\t}\n\trandom_01_result_set(v) {\n\t    this.numberobj_01_value_set(v);\n\t    this.outport_01_input_number_set(v);\n\t}\n\trandom_01_trigger_bang() {\n\t    {\n\t        this.random_01_result_set(this.random(0, this.random_01_limit));\n\t    }\n\t}\n\tbutton_01_output_bang() {}\n\tbutton_01_bangval_bang() {\n\t    this.getEngine().sendBangMessage(TAG(\"bangout\"), TAG(\"button_obj-41\"), this._currentTime);;\n\t    this.button_01_output_bang();\n\t}\n\tcycle_tilde_01_perform(frequency, phase_offset, out1, out2, n) {\n\t    var __cycle_tilde_01_f2i = this.cycle_tilde_01_f2i;\n\t    var __cycle_tilde_01_phasei = this.cycle_tilde_01_phasei;\n\t    var i;\n\t\n\t    for (i = 0; i < n; i++) {\n\t        {\n\t            let uint_phase;\n\t\n\t            {\n\t                {\n\t                    uint_phase = __cycle_tilde_01_phasei;\n\t                }\n\t            }\n\t\n\t            let idx = (uint32_rshift(uint_phase, 18));\n\t            let frac = (uint_phase & 262143) * 3.81471181759574e-6;\n\t            let y0 = this.cycle_tilde_01_buffer[idx];\n\t            let y1 = this.cycle_tilde_01_buffer[idx + 1 & 16383];\n\t            let y = y0 + frac * (y1 - y0);\n\t\n\t            {\n\t                let pincr = (uint32_trunc(frequency * __cycle_tilde_01_f2i));\n\t                __cycle_tilde_01_phasei = uint32_add(__cycle_tilde_01_phasei, pincr);\n\t            }\n\t\n\t            out1[i] = y;\n\t            out2[i] = uint_phase * 0.232830643653869629e-9;\n\t            continue;\n\t        }\n\t    }\n\t\n\t    this.cycle_tilde_01_phasei = __cycle_tilde_01_phasei;\n\t}\n\tparamtilde_01_perform(gain, out, n) {\n\t    var __paramtilde_01_sigbuf = this.paramtilde_01_sigbuf;\n\t    var __paramtilde_01_value = this.paramtilde_01_value;\n\t    var __paramtilde_01_lastIndex = this.paramtilde_01_lastIndex;\n\t\n\t    for (var i = 0; i < n; i++) {\n\t        if (i >= __paramtilde_01_lastIndex) {\n\t            out[i] = gain[i] + __paramtilde_01_value;\n\t        } else {\n\t            out[i] = gain[i] + __paramtilde_01_sigbuf[i];\n\t        }\n\t    }\n\t\n\t    __paramtilde_01_lastIndex = 0;\n\t    this.paramtilde_01_lastIndex = __paramtilde_01_lastIndex;\n\t}\n\tsaw_tilde_01_perform(frequency, syncPhase, out1, out2, n) {\n\t    var __saw_tilde_01_didSync = this.saw_tilde_01_didSync;\n\t    var __saw_tilde_01_lastSyncDiff = this.saw_tilde_01_lastSyncDiff;\n\t    var __saw_tilde_01_lastSyncPhase = this.saw_tilde_01_lastSyncPhase;\n\t    var __saw_tilde_01_t = this.saw_tilde_01_t;\n\t    var i;\n\t\n\t    for (i = 0; i < n; i++) {\n\t        let dt = frequency / this.samplerate();\n\t        let t1 = __saw_tilde_01_t + 0.5;\n\t        t1 -= rnbo_trunc(t1);\n\t        let y = 2 * t1 - 1;\n\t        let syncDiff = 0 - __saw_tilde_01_lastSyncPhase;\n\t        __saw_tilde_01_lastSyncPhase = 0;\n\t        __saw_tilde_01_lastSyncDiff = syncDiff;\n\t        let lookahead = 0 + syncDiff;\n\t\n\t        if (t1 < dt) {\n\t            let d = t1 / dt;\n\t            y -= d + d - d * d - 1;\n\t        } else if (t1 + dt > 1) {\n\t            let d = (t1 - 1) / dt;\n\t            y -= d + d + d * d + 1;\n\t        } else if ((__saw_tilde_01_didSync)) {\n\t            y = 0;\n\t            __saw_tilde_01_didSync = false;\n\t        } else if (lookahead > 1) {\n\t            y *= 0.5;\n\t            __saw_tilde_01_t = 0;\n\t            __saw_tilde_01_didSync = true;\n\t        }\n\t\n\t        __saw_tilde_01_t += dt;\n\t\n\t        if (dt > 0) {\n\t            while (__saw_tilde_01_t >= 1) {\n\t                __saw_tilde_01_t -= 1;\n\t            }\n\t        } else {\n\t            while (__saw_tilde_01_t <= 0) {\n\t                __saw_tilde_01_t += 1;\n\t            }\n\t        }\n\t\n\t        y = this.saw_tilde_01_dcblocker_next(y, 0.9997);\n\t        out1[i] = 0.5 * y;\n\t        out2[i] = __saw_tilde_01_t;\n\t    }\n\t\n\t    this.saw_tilde_01_t = __saw_tilde_01_t;\n\t    this.saw_tilde_01_lastSyncPhase = __saw_tilde_01_lastSyncPhase;\n\t    this.saw_tilde_01_lastSyncDiff = __saw_tilde_01_lastSyncDiff;\n\t    this.saw_tilde_01_didSync = __saw_tilde_01_didSync;\n\t}\n\trect_tilde_01_perform(frequency, pulsewidth, syncPhase, out1, out2, n) {\n\t    var __rect_tilde_01_xHistory = this.rect_tilde_01_xHistory;\n\t    var __rect_tilde_01_yHistory = this.rect_tilde_01_yHistory;\n\t    var __rect_tilde_01_didSync = this.rect_tilde_01_didSync;\n\t    var __rect_tilde_01_t = this.rect_tilde_01_t;\n\t    var __rect_tilde_01_lastSyncDiff = this.rect_tilde_01_lastSyncDiff;\n\t    var __rect_tilde_01_lastSyncPhase = this.rect_tilde_01_lastSyncPhase;\n\t    var i;\n\t\n\t    for (i = 0; i < n; i++) {\n\t        var __frequency = frequency;\n\t        __frequency = rnbo_abs(__frequency);\n\t        let dt = __frequency / this.samplerate();\n\t        let pw = 0.5;\n\t        let syncDiff = 0 - __rect_tilde_01_lastSyncPhase;\n\t        __rect_tilde_01_lastSyncPhase = 0;\n\t        __rect_tilde_01_lastSyncDiff = syncDiff;\n\t        let syncLookahead = 0 + syncDiff;\n\t        let tCurr = __rect_tilde_01_t;\n\t        let tPrev = tCurr - dt;\n\t        let tNext = tCurr + dt;\n\t\n\t        if (tPrev < 0) {\n\t            while (tPrev < 0) {\n\t                tPrev += 1;\n\t            }\n\t        }\n\t\n\t        if (tNext > 1) {\n\t            while (tNext >= 1) {\n\t                tNext -= 1;\n\t            }\n\t        }\n\t\n\t        let yNext = this.rect_tilde_01_rectangle(tNext, pw);\n\t        let yCurr = this.rect_tilde_01_rectangle(tCurr, pw);\n\t        let yPrev = this.rect_tilde_01_rectangle(tPrev, pw);\n\t\n\t        if (yPrev < yCurr) {\n\t            let d = tCurr / dt;\n\t            yCurr += d - 0.5 * d * d - 0.5;\n\t        } else if (yCurr < yNext) {\n\t            let d = (1 - tCurr) / dt;\n\t            yCurr += 0.5 * d * d + d + 0.5;\n\t        } else if (yPrev > yCurr) {\n\t            let d = (tCurr - pw) / dt;\n\t            yCurr -= d - 0.5 * d * d - 0.5;\n\t        } else if (yCurr > yNext) {\n\t            let d = (pw - tCurr) / dt;\n\t            yCurr -= 0.5 * d * d + d + 0.5;\n\t        } else if ((__rect_tilde_01_didSync)) {\n\t            yCurr = 0.25;\n\t            __rect_tilde_01_didSync = false;\n\t        } else if (syncLookahead > 1) {\n\t            if (yCurr < 0) {\n\t                yCurr = -0.125;\n\t            }\n\t\n\t            __rect_tilde_01_t = 0;\n\t            __rect_tilde_01_didSync = true;\n\t        }\n\t\n\t        __rect_tilde_01_t += dt;\n\t\n\t        if (dt > 0) {\n\t            while (__rect_tilde_01_t >= 1) {\n\t                __rect_tilde_01_t -= 1;\n\t            }\n\t        } else {\n\t            while (__rect_tilde_01_t <= 0) {\n\t                __rect_tilde_01_t += 1;\n\t            }\n\t        }\n\t\n\t        let output = yCurr - __rect_tilde_01_yHistory + __rect_tilde_01_xHistory * 0.9997;\n\t        __rect_tilde_01_xHistory = output;\n\t        __rect_tilde_01_yHistory = yCurr;\n\t        out1[i] = 0.5 * output;\n\t        out2[i] = __rect_tilde_01_t;\n\t    }\n\t\n\t    this.rect_tilde_01_lastSyncPhase = __rect_tilde_01_lastSyncPhase;\n\t    this.rect_tilde_01_lastSyncDiff = __rect_tilde_01_lastSyncDiff;\n\t    this.rect_tilde_01_t = __rect_tilde_01_t;\n\t    this.rect_tilde_01_didSync = __rect_tilde_01_didSync;\n\t    this.rect_tilde_01_yHistory = __rect_tilde_01_yHistory;\n\t    this.rect_tilde_01_xHistory = __rect_tilde_01_xHistory;\n\t}\n\tselector_01_perform(onoff, in1, in2, in3, out, n) {\n\t    var i;\n\t\n\t    for (i = 0; i < n; i++) {\n\t        if (onoff >= 1 && onoff < 2)\n\t            out[i] = in1[i];\n\t        else if (onoff >= 2 && onoff < 3)\n\t            out[i] = in2[i];\n\t        else if (onoff >= 3 && onoff < 4)\n\t            out[i] = in3[i];\n\t        else\n\t            out[i] = 0;\n\t    }\n\t}\n\tdspexpr_02_perform(in1, in2, out1, n) {\n\t    var i;\n\t\n\t    for (i = 0; i < n; i++) {\n\t        out1[i] = in1[i] * 0.5;//#map:_###_obj_###_:1\n\t    }\n\t}\n\tdspexpr_01_perform(in1, in2, out1, n) {\n\t    var i;\n\t\n\t    for (i = 0; i < n; i++) {\n\t        out1[i] = in1[i] * in2[i];//#map:_###_obj_###_:1\n\t    }\n\t}\n\tgroove_01_perform(rate_auto, begin, end, out1, sync, n) {\n\t    var __groove_01_crossfade = this.groove_01_crossfade;\n\t    var __groove_01_loop = this.groove_01_loop;\n\t    var __groove_01_playStatus = this.groove_01_playStatus;\n\t    var __groove_01_readIndex = this.groove_01_readIndex;\n\t    var __groove_01_incomingChange = this.groove_01_incomingChange;\n\t    var __groove_01_changeIncomingInSamples = this.groove_01_changeIncomingInSamples;\n\t    var out = [out1];\n\t    let bufferLength = (this.groove_01_buffer.getSize());\n\t    let i = 0;\n\t\n\t    if (bufferLength > 1) {\n\t        const effectiveChannels = this.minimum(this.groove_01_buffer.getChannels(), 1);\n\t        const srMult = 0.001 * this.groove_01_buffer.getSampleRate();\n\t        const srInv = 1 / this.samplerate();\n\t        const rateMult = this.groove_01_buffer.getSampleRate() * srInv;\n\t\n\t        for (; i < n; i++) {\n\t            let channel = 0;\n\t            let offset = 0;\n\t            let loopMin = 0 * srMult;\n\t            loopMin = (loopMin > bufferLength - 1 ? bufferLength - 1 : (loopMin < 0 ? 0 : loopMin));\n\t            let loopMax = bufferLength;\n\t            loopMax = (loopMax > bufferLength ? bufferLength : (loopMax < 0 ? 0 : loopMax));\n\t\n\t            if (loopMin >= loopMax) {\n\t                offset = loopMax;\n\t                loopMax = bufferLength;\n\t                loopMin -= offset;\n\t            }\n\t\n\t            let loopLength = loopMax - loopMin;\n\t            let currentRate = 1 * rateMult;\n\t            let currentSync = 0;\n\t\n\t            if (__groove_01_changeIncomingInSamples > 0) {\n\t                __groove_01_changeIncomingInSamples--;\n\t\n\t                if (__groove_01_changeIncomingInSamples <= 0) {\n\t                    if (__groove_01_incomingChange == 1) {\n\t                        if (currentRate < 0) {\n\t                            __groove_01_readIndex = loopMax - 1;\n\t                        } else {\n\t                            __groove_01_readIndex = loopMin;\n\t                        }\n\t\n\t                        __groove_01_playStatus = 1;\n\t                    } else if (__groove_01_incomingChange == 0) {\n\t                        __groove_01_playStatus = 0;\n\t                    }\n\t\n\t                    __groove_01_incomingChange = 2;\n\t                }\n\t            }\n\t\n\t            if (loopLength > 0) {\n\t                if (currentRate != 0) {\n\t                    if (__groove_01_playStatus == 1) {\n\t                        if ((__groove_01_loop)) {\n\t                            while (__groove_01_readIndex < loopMin) {\n\t                                __groove_01_readIndex += loopLength;\n\t                            }\n\t\n\t                            while (__groove_01_readIndex >= loopMax) {\n\t                                __groove_01_readIndex -= loopLength;\n\t                            }\n\t                        } else if (__groove_01_readIndex >= loopMax || __groove_01_readIndex < loopMin) {\n\t                            __groove_01_playStatus = 0;\n\t                            break;\n\t                        }\n\t\n\t                        for (; channel < effectiveChannels; channel++) {\n\t                            const outSample = (currentRate == 1 ? this.groove_01_getSample((channel), rnbo_trunc(__groove_01_readIndex), offset, bufferLength) : this.groove_01_interpolatedSample(\n\t                                (channel),\n\t                                __groove_01_readIndex,\n\t                                loopMax,\n\t                                loopLength,\n\t                                offset,\n\t                                bufferLength\n\t                            ));\n\t\n\t                            if (__groove_01_crossfade > 0) {\n\t                                out[channel][i] = this.groove_01_crossfadedSample(\n\t                                    outSample,\n\t                                    __groove_01_readIndex,\n\t                                    (channel),\n\t                                    currentRate,\n\t                                    loopMin,\n\t                                    loopMax,\n\t                                    loopLength,\n\t                                    offset,\n\t                                    bufferLength\n\t                                );\n\t                            } else {\n\t                                out[channel][i] = outSample;\n\t                            }\n\t                        }\n\t\n\t                        __groove_01_readIndex += currentRate;\n\t                    }\n\t                }\n\t            }\n\t\n\t            for (; channel < 1; channel++) {\n\t                if (__groove_01_playStatus <= 0)\n\t                    sync[i] = 0;\n\t\n\t                out[channel][i] = 0;\n\t            }\n\t        }\n\t    }\n\t\n\t    for (; i < n; i++) {\n\t        if (__groove_01_playStatus <= 0)\n\t            sync[i] = 0;\n\t\n\t        for (let channel = 0; channel < 1; channel++) {\n\t            out[channel][i] = 0;\n\t        }\n\t    }\n\t\n\t    this.groove_01_changeIncomingInSamples = __groove_01_changeIncomingInSamples;\n\t    this.groove_01_incomingChange = __groove_01_incomingChange;\n\t    this.groove_01_readIndex = __groove_01_readIndex;\n\t    this.groove_01_playStatus = __groove_01_playStatus;\n\t}\n\tphasor_01_perform(freq, out, n) {\n\t    var __phasor_01_sigbuf = this.phasor_01_sigbuf;\n\t\n\t    for (var i = 0; i < n; i++) {\n\t        out[i] = this.phasor_01_ph_next(1, -1);\n\t        __phasor_01_sigbuf[i] = -1;\n\t    }\n\t}\n\twhatobject_01_perform(input_signal, impulses, indices, n) {\n\t    var __whatobject_01_syncupdate = this.whatobject_01_syncupdate;\n\t    var __whatobject_01_triggermode = this.whatobject_01_triggermode;\n\t    var __whatobject_01_matches = this.whatobject_01_matches;\n\t\n\t    for (let i = 0; i < n; i++) {\n\t        let result = this.whatobject_01_detector_next(\n\t            input_signal[i],\n\t            __whatobject_01_matches,\n\t            __whatobject_01_triggermode,\n\t            __whatobject_01_syncupdate\n\t        );\n\t\n\t        impulses[i] = result[0];\n\t        indices[i] = result[1];\n\t    }\n\t}\n\tedge_01_perform(input, n) {\n\t    var __edge_01_currentState = this.edge_01_currentState;\n\t\n\t    for (var i = 0; i < n; i++) {\n\t        if (__edge_01_currentState == 1) {\n\t            if (input[i] == 0.) {\n\t                this.getEngine().scheduleClockEvent(this, -1584063977, this.sampsToMs(i) + this._currentTime);;\n\t                __edge_01_currentState = 0;\n\t            }\n\t        } else {\n\t            if (input[i] != 0.) {\n\t                this.getEngine().scheduleClockEvent(this, -611950441, this.sampsToMs(i) + this._currentTime);;\n\t                __edge_01_currentState = 1;\n\t            }\n\t        }\n\t    }\n\t\n\t    this.edge_01_currentState = __edge_01_currentState;\n\t}\n\tstackprotect_perform(n) {\n\t    var __stackprotect_count = this.stackprotect_count;\n\t    __stackprotect_count = 0;\n\t    this.stackprotect_count = __stackprotect_count;\n\t}\n\tdata_01_srout_set(v) {}\n\tdata_01_chanout_set(v) {}\n\tdata_01_sizeout_set(v) {\n\t    this.data_01_sizeout = v;\n\t}\n\tparamtilde_01_value_setter(v) {\n\t    if ((!(isNaN(1))) && v >= 1) {\n\t        v = 1;\n\t    }\n\t\n\t    if ((!(isNaN(0))) && v <= 0) {\n\t        v = 0;\n\t    }\n\t\n\t    this.paramtilde_01_value = v;\n\t}\n\trandom_01_limit_setter(v) {\n\t    if (v >= 0)\n\t        this.random_01_limit = v;\n\t}\n\tnumberobj_01_value_setter(v) {\n\t    let localvalue = v;\n\t\n\t    if (this.numberobj_01_currentFormat != 6) {\n\t        localvalue = rnbo_trunc(localvalue);\n\t    }\n\t\n\t    this.numberobj_01_value = localvalue;\n\t}\n\tparam_01_getPresetValue(preset) {\n\t    preset[\"value\"] = this.param_01_value;\n\t}\n\tparam_01_setPresetValue(preset) {\n\t    if ((stateIsEmpty(preset)))\n\t        return;\n\t\n\t    this.param_01_value_set(preset[\"value\"]);\n\t}\n\tcycle_tilde_01_ph_next(freq, reset) {\n\t    {\n\t        {\n\t            if (reset >= 0.)\n\t                this.cycle_tilde_01_ph_currentPhase = reset;\n\t        }\n\t    }\n\t\n\t    const pincr = freq * this.cycle_tilde_01_ph_conv;\n\t\n\t    if (this.cycle_tilde_01_ph_currentPhase < 0.)\n\t        this.cycle_tilde_01_ph_currentPhase = 1. + this.cycle_tilde_01_ph_currentPhase;\n\t\n\t    if (this.cycle_tilde_01_ph_currentPhase > 1.)\n\t        this.cycle_tilde_01_ph_currentPhase = this.cycle_tilde_01_ph_currentPhase - 1.;\n\t\n\t    var tmp = this.cycle_tilde_01_ph_currentPhase;\n\t    this.cycle_tilde_01_ph_currentPhase += pincr;\n\t    return tmp;\n\t}\n\tcycle_tilde_01_ph_reset() {\n\t    this.cycle_tilde_01_ph_currentPhase = 0;\n\t}\n\tcycle_tilde_01_ph_dspsetup() {\n\t    this.cycle_tilde_01_ph_conv = 1 / this.sr;\n\t}\n\tcycle_tilde_01_dspsetup(force) {\n\t    if ((this.cycle_tilde_01_setupDone) && (!(force)))\n\t        return;\n\t\n\t    this.cycle_tilde_01_phasei = 0;\n\t    this.cycle_tilde_01_f2i = 4294967296 / this.samplerate();\n\t    this.cycle_tilde_01_wrap = (this.cycle_tilde_01_buffer.getSize()) - 1;\n\t    this.cycle_tilde_01_setupDone = true;\n\t    this.cycle_tilde_01_ph_dspsetup();\n\t}\n\tcycle_tilde_01_bufferUpdated() {\n\t    this.cycle_tilde_01_wrap = (this.cycle_tilde_01_buffer.getSize()) - 1;\n\t}\n\tparamtilde_01_dspsetup(force) {\n\t    if ((this.paramtilde_01_setupDone) && (!(force)))\n\t        return;\n\t\n\t    this.paramtilde_01_lastIndex = 0;\n\t    this.paramtilde_01_setupDone = true;\n\t}\n\tsaw_tilde_01_dcblocker_next(x, gain) {\n\t    var y = x - this.saw_tilde_01_dcblocker_xm1 + this.saw_tilde_01_dcblocker_ym1 * gain;\n\t    this.saw_tilde_01_dcblocker_xm1 = x;\n\t    this.saw_tilde_01_dcblocker_ym1 = y;\n\t    return y;\n\t}\n\tsaw_tilde_01_dcblocker_reset() {\n\t    this.saw_tilde_01_dcblocker_xm1 = 0;\n\t    this.saw_tilde_01_dcblocker_ym1 = 0;\n\t}\n\tsaw_tilde_01_dcblocker_dspsetup() {\n\t    this.saw_tilde_01_dcblocker_reset();\n\t}\n\tsaw_tilde_01_dspsetup(force) {\n\t    if ((this.saw_tilde_01_setupDone) && (!(force)))\n\t        return;\n\t\n\t    this.saw_tilde_01_setupDone = true;\n\t    this.saw_tilde_01_dcblocker_dspsetup();\n\t}\n\tparam_02_getPresetValue(preset) {\n\t    preset[\"value\"] = this.param_02_value;\n\t}\n\tparam_02_setPresetValue(preset) {\n\t    if ((stateIsEmpty(preset)))\n\t        return;\n\t\n\t    this.param_02_value_set(preset[\"value\"]);\n\t}\n\trect_tilde_01_rectangle(phase, pulsewidth) {\n\t    if (phase < pulsewidth) {\n\t        return 1;\n\t    } else {\n\t        return -1;\n\t    }\n\t}\n\tdata_01_init() {\n\t    this.data_01_buffer.setWantsFill(true);\n\t}\n\tdata_01_evaluateSizeExpr(samplerate, vectorsize) {\n\t    let size = 0;\n\t    return (size);\n\t}\n\tdata_01_dspsetup(force) {\n\t    if ((this.data_01_setupDone) && (!(force)))\n\t        return;\n\t\n\t    if (this.data_01_sizemode == 2) {\n\t        this.data_01_buffer = this.data_01_buffer.setSize((this.mstosamps(this.data_01_sizems)));\n\t        updateDataRef(this, this.data_01_buffer);\n\t    } else if (this.data_01_sizemode == 3) {\n\t        this.data_01_buffer = this.data_01_buffer.setSize(this.data_01_evaluateSizeExpr(this.samplerate(), this.vectorsize()));\n\t        updateDataRef(this, this.data_01_buffer);\n\t    }\n\t\n\t    this.data_01_setupDone = true;\n\t}\n\tdata_01_bufferUpdated() {\n\t    this.data_01_report();\n\t}\n\tdata_01_report() {\n\t    this.data_01_srout_set(this.data_01_buffer.getSampleRate());\n\t    this.data_01_chanout_set(this.data_01_buffer.getChannels());\n\t    this.data_01_sizeout_set(this.data_01_buffer.getSize());\n\t}\n\tgroove_01_getSample(channel, index, offset, bufferLength) {\n\t    if (offset > 0) {\n\t        index += offset;\n\t\n\t        if (index >= bufferLength)\n\t            index -= bufferLength;\n\t    }\n\t\n\t    return this.groove_01_buffer.getSample(channel, index);\n\t}\n\tgroove_01_interpolatedSample(channel, index, end, length, offset, bufferLength) {\n\t    let index1 = (rnbo_trunc(index));\n\t    let i_x = index - index1;\n\t    let i_1px = 1. + i_x;\n\t    let i_1mx = 1. - i_x;\n\t    let i_2mx = 2. - i_x;\n\t    let i_a = i_1mx * i_2mx;\n\t    let i_b = i_1px * i_x;\n\t    let i_p1 = -.1666667 * i_a * i_x;\n\t    let i_p2 = .5 * i_1px * i_a;\n\t    let i_p3 = .5 * i_b * i_2mx;\n\t    let i_p4 = -.1666667 * i_b * i_1mx;\n\t    let index2 = (index1 + 1);\n\t\n\t    if (index2 >= end)\n\t        index2 -= length;\n\t\n\t    let index3 = (index1 + 2);\n\t\n\t    if (index3 >= end)\n\t        index3 -= length;\n\t\n\t    let index4 = (index1 + 3);\n\t\n\t    if (index4 >= end)\n\t        index4 -= length;\n\t\n\t    return this.groove_01_getSample(channel, index1, offset, bufferLength) * i_p1 + this.groove_01_getSample(channel, index2, offset, bufferLength) * i_p2 + this.groove_01_getSample(channel, index3, offset, bufferLength) * i_p3 + this.groove_01_getSample(channel, index4, offset, bufferLength) * i_p4;\n\t}\n\tgroove_01_crossfadedSample(\n\t    out,\n\t    readIndex,\n\t    channel,\n\t    rate,\n\t    loopMin,\n\t    loopMax,\n\t    loopLength,\n\t    offset,\n\t    bufferLength\n\t) {\n\t    let crossFadeStart1 = this.maximum(loopMin - this.groove_01_crossfadeInSamples, 0);\n\t    let crossFadeEnd1 = this.minimum(crossFadeStart1 + this.groove_01_crossfadeInSamples, bufferLength);\n\t    let crossFadeStart2 = crossFadeStart1 + loopLength;\n\t    let crossFadeEnd2 = this.minimum(crossFadeEnd1 + loopLength, bufferLength);\n\t    let crossFadeLength = crossFadeEnd2 - crossFadeStart2;\n\t\n\t    if (crossFadeLength > 0) {\n\t        crossFadeEnd1 = crossFadeStart1 + crossFadeLength;\n\t        let diff = -1;\n\t        let addFactor = 0;\n\t\n\t        if (readIndex >= crossFadeStart2) {\n\t            diff = readIndex - crossFadeStart2;\n\t            addFactor = -1;\n\t        } else if (readIndex < crossFadeEnd1) {\n\t            diff = crossFadeEnd1 - readIndex + loopMax - crossFadeStart2;\n\t            addFactor = 1;\n\t        }\n\t\n\t        if (diff >= 0) {\n\t            const out2ReadIndex = readIndex + loopLength * addFactor;\n\t            const out2 = (rate == 1 ? this.groove_01_getSample(channel, rnbo_trunc(out2ReadIndex), offset, bufferLength) : this.groove_01_interpolatedSample(channel, out2ReadIndex, loopMax, loopLength, offset, bufferLength));\n\t            const out2Factor = diff / crossFadeLength;\n\t            const out1Factor = 1 - out2Factor;\n\t            return out * out1Factor + out2 * out2Factor;\n\t        }\n\t    }\n\t\n\t    return out;\n\t}\n\tgroove_01_dspsetup(force) {\n\t    if ((this.groove_01_setupDone) && (!(force)))\n\t        return;\n\t\n\t    this.groove_01_crossfadeInSamples = this.mstosamps(this.groove_01_crossfade);\n\t    this.groove_01_setupDone = true;\n\t}\n\tedge_01_dspsetup(force) {\n\t    if ((this.edge_01_setupDone) && (!(force)))\n\t        return;\n\t\n\t    this.edge_01_setupDone = true;\n\t}\n\tphasor_01_ph_next(freq, reset) {\n\t    const pincr = 1 * this.phasor_01_ph_conv;\n\t\n\t    if (this.phasor_01_ph_currentPhase < 0.)\n\t        this.phasor_01_ph_currentPhase = 1. + this.phasor_01_ph_currentPhase;\n\t\n\t    if (this.phasor_01_ph_currentPhase > 1.)\n\t        this.phasor_01_ph_currentPhase = this.phasor_01_ph_currentPhase - 1.;\n\t\n\t    var tmp = this.phasor_01_ph_currentPhase;\n\t    this.phasor_01_ph_currentPhase += pincr;\n\t    return tmp;\n\t}\n\tphasor_01_ph_reset() {\n\t    this.phasor_01_ph_currentPhase = 0;\n\t}\n\tphasor_01_ph_dspsetup() {\n\t    this.phasor_01_ph_conv = 1 / this.sr;\n\t}\n\tphasor_01_dspsetup(force) {\n\t    if ((this.phasor_01_setupDone) && (!(force)))\n\t        return;\n\t\n\t    this.phasor_01_conv = 1 / this.samplerate();\n\t    this.phasor_01_setupDone = true;\n\t    this.phasor_01_ph_dspsetup();\n\t}\n\trandom_01_nz_reset() {\n\t    xoshiro_reset(\n\t        systemticks() + this.voice() + this.random(0, 10000),\n\t        this.random_01_nz_state\n\t    );\n\t}\n\trandom_01_nz_init() {\n\t    this.random_01_nz_reset();\n\t}\n\trandom_01_nz_seed(v) {\n\t    xoshiro_reset(v, this.random_01_nz_state);\n\t}\n\trandom_01_nz_next() {\n\t    return xoshiro_next(this.random_01_nz_state);\n\t}\n\twhatobject_01_detector_init() {\n\t    this.whatobject_01_detector_prev1 = 0.0;\n\t    this.whatobject_01_detector_prev2 = 0.0;\n\t    this.whatobject_01_detector_reversal = false;\n\t    this.whatobject_01_detector_prevReversal = false;\n\t}\n\twhatobject_01_detector_isReverse(prev, prev2, signal, prevReversal) {\n\t    if ((prevReversal)) {\n\t        return false;\n\t    }\n\t\n\t    if (prev2 < prev && prev > signal) {\n\t        return true;\n\t    }\n\t\n\t    if (prev2 > prev && prev < signal) {\n\t        return true;\n\t    }\n\t\n\t    return false;\n\t}\n\twhatobject_01_detector_inTolerance(prev, curent, tolerance) {\n\t    return rnbo_fabs(prev - curent) < tolerance;\n\t}\n\twhatobject_01_detector_ascend(prev, curent, thresh) {\n\t    return prev <= thresh && curent > thresh;\n\t}\n\twhatobject_01_detector_descend(prev, curent, thresh) {\n\t    return prev >= thresh && curent < thresh;\n\t}\n\twhatobject_01_detector_next(signal, threshold, mode, sync) {\n\t    this.whatobject_01_detector_reversal = this.whatobject_01_detector_isReverse(\n\t        this.whatobject_01_detector_prev1,\n\t        this.whatobject_01_detector_prev2,\n\t        signal,\n\t        this.whatobject_01_detector_reversal\n\t    );\n\t\n\t    if ((sync) && (this.whatobject_01_detector_reversal) || (!(sync))) {\n\t        this.whatobject_01_detector_matchesReg = threshold;\n\t    }\n\t\n\t    let trigger = false;\n\t\n\t    for (let j = 0; j < this.whatobject_01_detector_matchesReg.length; j++) {\n\t        const thresh = (this.whatobject_01_detector_matchesReg[j]);\n\t        trigger = false;\n\t\n\t        if ((this.whatobject_01_detector_reversal) && thresh == 0.0 && mode != 3) {\n\t            trigger = true;\n\t        } else {\n\t            switch (mode) {\n\t            case 0:\n\t                trigger = (this.whatobject_01_detector_ascend(this.whatobject_01_detector_prev1, signal, thresh)) && (this.whatobject_01_detector_inTolerance(\n\t                    this.whatobject_01_detector_prev1,\n\t                    signal,\n\t                    this.whatobject_01_detector_sahTolerance\n\t                ));\n\t\n\t                break;\n\t            case 1:\n\t                trigger = (this.whatobject_01_detector_descend(this.whatobject_01_detector_prev1, signal, thresh)) && (this.whatobject_01_detector_inTolerance(\n\t                    this.whatobject_01_detector_prev1,\n\t                    signal,\n\t                    this.whatobject_01_detector_sahTolerance\n\t                ));\n\t\n\t                break;\n\t            case 2:\n\t                trigger = (this.whatobject_01_detector_ascend(this.whatobject_01_detector_prev1, signal, thresh)) || (this.whatobject_01_detector_descend(this.whatobject_01_detector_prev1, signal, thresh)) && (this.whatobject_01_detector_inTolerance(\n\t                    this.whatobject_01_detector_prev1,\n\t                    signal,\n\t                    this.whatobject_01_detector_sahTolerance\n\t                ));\n\t\n\t                break;\n\t            case 3:\n\t                trigger = signal == thresh;\n\t                break;\n\t            }\n\t        }\n\t\n\t        if ((trigger)) {\n\t            this.whatobject_01_detector_matchedIndex = j;\n\t            break;\n\t        }\n\t    }\n\t\n\t    this.whatobject_01_detector_prev2 = this.whatobject_01_detector_prev1;\n\t    this.whatobject_01_detector_prev1 = signal;\n\t    return [trigger, this.whatobject_01_detector_matchedIndex];\n\t}\n\twhatobject_01_detector_reset() {\n\t    this.whatobject_01_detector_prev1 = 0;\n\t    this.whatobject_01_detector_prev2 = 0;\n\t    this.whatobject_01_detector_sahTolerance = 0.1;\n\t    this.whatobject_01_detector_matchedIndex = 0;\n\t    this.whatobject_01_detector_matchesReg = [0];\n\t    this.whatobject_01_detector_reversal = false;\n\t    this.whatobject_01_detector_prevReversal = false;\n\t}\n\tnumberobj_01_init() {\n\t    this.numberobj_01_currentFormat = 0;\n\t    this.getEngine().sendNumMessage(TAG(\"setup\"), TAG(\"number_obj-44\"), 1, this._currentTime);\n\t}\n\tnumberobj_01_getPresetValue(preset) {\n\t    preset[\"value\"] = this.numberobj_01_value;\n\t}\n\tnumberobj_01_setPresetValue(preset) {\n\t    if ((stateIsEmpty(preset)))\n\t        return;\n\t\n\t    this.numberobj_01_value_set(preset[\"value\"]);\n\t}\n\tglobaltransport_getTempoAtSample(sampleOffset) {\n\t    return (this.vs > 0 ? this.globaltransport_tempo[sampleOffset] : this.globaltransport_lastTempo);\n\t}\n\tglobaltransport_getTempo() {\n\t    return this.globaltransport_getTempoAtSample(this.sampleOffsetIntoNextAudioBuffer);\n\t}\n\tglobaltransport_getStateAtSample(sampleOffset) {\n\t    return (this.vs > 0 ? this.globaltransport_state[sampleOffset] : this.globaltransport_lastState);\n\t}\n\tglobaltransport_getState() {\n\t    return this.globaltransport_getStateAtSample(this.sampleOffsetIntoNextAudioBuffer);\n\t}\n\tglobaltransport_getBeatTimeAtMsTime(time) {\n\t    var i = 2;\n\t\n\t    while (i < this.globaltransport_beatTimeChanges.length && this.globaltransport_beatTimeChanges[i + 1] <= time) {\n\t        i += 2;\n\t    }\n\t\n\t    i -= 2;\n\t    var beatTimeBase = this.globaltransport_beatTimeChanges[i];\n\t\n\t    if (this.globaltransport_getState() == 0)\n\t        return beatTimeBase;\n\t\n\t    var beatTimeBaseMsTime = this.globaltransport_beatTimeChanges[i + 1];\n\t    var diff = time - beatTimeBaseMsTime;\n\t    return beatTimeBase + this.mstobeats(diff);\n\t}\n\tglobaltransport_setTempo(tempo, notify) {\n\t    if ((notify)) {\n\t        this.processTempoEvent(this.currenttime(), tempo);\n\t        this.globaltransport_notify = true;\n\t    } else if (this.globaltransport_getTempo() != tempo) {\n\t        const ct = this.currenttime();\n\t        this.globaltransport_beatTimeChanges.push(this.globaltransport_getBeatTimeAtMsTime(ct));\n\t        this.globaltransport_beatTimeChanges.push(ct);\n\t\n\t        fillSignal(\n\t            this.globaltransport_tempo,\n\t            this.vs,\n\t            tempo,\n\t            (this.sampleOffsetIntoNextAudioBuffer)\n\t        );\n\t\n\t        this.globaltransport_lastTempo = tempo;\n\t        this.globaltransport_tempoNeedsReset = true;\n\t        return true;\n\t    }\n\t\n\t    return false;\n\t}\n\tglobaltransport_getBeatTime() {\n\t    return this.globaltransport_getBeatTimeAtMsTime(this.currenttime());\n\t}\n\tglobaltransport_setState(state, notify) {\n\t    if ((notify)) {\n\t        this.processTransportEvent(this.currenttime(), TransportState(state));\n\t        this.globaltransport_notify = true;\n\t    } else if (this.globaltransport_getState() != state) {\n\t        fillSignal(\n\t            this.globaltransport_state,\n\t            this.vs,\n\t            state,\n\t            (this.sampleOffsetIntoNextAudioBuffer)\n\t        );\n\t\n\t        this.globaltransport_lastState = TransportState(state);\n\t        this.globaltransport_stateNeedsReset = true;\n\t\n\t        if (state == 0) {\n\t            this.globaltransport_beatTimeChanges.push(this.globaltransport_getBeatTime());\n\t            this.globaltransport_beatTimeChanges.push(this.currenttime());\n\t        }\n\t\n\t        return true;\n\t    }\n\t\n\t    return false;\n\t}\n\tglobaltransport_setBeatTime(beattime, notify) {\n\t    if ((notify)) {\n\t        this.processBeatTimeEvent(this.currenttime(), beattime);\n\t        this.globaltransport_notify = true;\n\t        return false;\n\t    } else {\n\t        var beatTimeHasChanged = false;\n\t        var oldBeatTime = (this.globaltransport_getBeatTime());\n\t        var newBeatTime = (beattime);\n\t\n\t        if (oldBeatTime != newBeatTime) {\n\t            beatTimeHasChanged = true;\n\t        }\n\t\n\t        this.globaltransport_beatTimeChanges.push(beattime);\n\t        this.globaltransport_beatTimeChanges.push(this.currenttime());\n\t        return beatTimeHasChanged;\n\t    }\n\t}\n\tglobaltransport_getBeatTimeAtSample(sampleOffset) {\n\t    var msOffset = this.sampstoms(sampleOffset);\n\t    return this.globaltransport_getBeatTimeAtMsTime(this.currenttime() + msOffset);\n\t}\n\tglobaltransport_getTimeSignatureAtMsTime(time) {\n\t    var i = 3;\n\t\n\t    while (i < this.globaltransport_timeSignatureChanges.length && this.globaltransport_timeSignatureChanges[i + 2] <= time) {\n\t        i += 3;\n\t    }\n\t\n\t    i -= 3;\n\t\n\t    return [\n\t        this.globaltransport_timeSignatureChanges[i],\n\t        this.globaltransport_timeSignatureChanges[i + 1]\n\t    ];\n\t}\n\tglobaltransport_getTimeSignature() {\n\t    return this.globaltransport_getTimeSignatureAtMsTime(this.currenttime());\n\t}\n\tglobaltransport_getTimeSignatureAtSample(sampleOffset) {\n\t    var msOffset = this.sampstoms(sampleOffset);\n\t    return this.globaltransport_getTimeSignatureAtMsTime(this.currenttime() + msOffset);\n\t}\n\tglobaltransport_setTimeSignature(numerator, denominator, notify) {\n\t    if ((notify)) {\n\t        this.processTimeSignatureEvent(this.currenttime(), (numerator), (denominator));\n\t        this.globaltransport_notify = true;\n\t    } else {\n\t        var currentSig = this.globaltransport_getTimeSignature();\n\t\n\t        if (currentSig[0] != numerator || currentSig[1] != denominator) {\n\t            this.globaltransport_timeSignatureChanges.push(numerator);\n\t            this.globaltransport_timeSignatureChanges.push(denominator);\n\t            this.globaltransport_timeSignatureChanges.push(this.currenttime());\n\t            return true;\n\t        }\n\t    }\n\t\n\t    return false;\n\t}\n\tglobaltransport_advance() {\n\t    if ((this.globaltransport_tempoNeedsReset)) {\n\t        fillSignal(this.globaltransport_tempo, this.vs, this.globaltransport_lastTempo);\n\t        this.globaltransport_tempoNeedsReset = false;\n\t\n\t        if ((this.globaltransport_notify)) {\n\t            this.getEngine().sendTempoEvent(this.globaltransport_lastTempo);\n\t        }\n\t    }\n\t\n\t    if ((this.globaltransport_stateNeedsReset)) {\n\t        fillSignal(this.globaltransport_state, this.vs, this.globaltransport_lastState);\n\t        this.globaltransport_stateNeedsReset = false;\n\t\n\t        if ((this.globaltransport_notify)) {\n\t            this.getEngine().sendTransportEvent(TransportState(this.globaltransport_lastState));\n\t        }\n\t    }\n\t\n\t    if (this.globaltransport_beatTimeChanges.length > 2) {\n\t        this.globaltransport_beatTimeChanges[0] = this.globaltransport_beatTimeChanges[this.globaltransport_beatTimeChanges.length - 2];\n\t        this.globaltransport_beatTimeChanges[1] = this.globaltransport_beatTimeChanges[this.globaltransport_beatTimeChanges.length - 1];\n\t        this.globaltransport_beatTimeChanges.length = 2;\n\t\n\t        if ((this.globaltransport_notify)) {\n\t            this.getEngine().sendBeatTimeEvent(this.globaltransport_beatTimeChanges[0]);\n\t        }\n\t    }\n\t\n\t    if (this.globaltransport_timeSignatureChanges.length > 3) {\n\t        this.globaltransport_timeSignatureChanges[0] = this.globaltransport_timeSignatureChanges[this.globaltransport_timeSignatureChanges.length - 3];\n\t        this.globaltransport_timeSignatureChanges[1] = this.globaltransport_timeSignatureChanges[this.globaltransport_timeSignatureChanges.length - 2];\n\t        this.globaltransport_timeSignatureChanges[2] = this.globaltransport_timeSignatureChanges[this.globaltransport_timeSignatureChanges.length - 1];\n\t        this.globaltransport_timeSignatureChanges.length = 3;\n\t\n\t        if ((this.globaltransport_notify)) {\n\t            this.getEngine().sendTimeSignatureEvent(\n\t                (this.globaltransport_timeSignatureChanges[0]),\n\t                (this.globaltransport_timeSignatureChanges[1])\n\t            );\n\t        }\n\t    }\n\t\n\t    this.globaltransport_notify = false;\n\t}\n\tglobaltransport_dspsetup(force) {\n\t    if ((this.globaltransport_setupDone) && (!(force)))\n\t        return;\n\t\n\t    fillSignal(this.globaltransport_tempo, this.vs, this.globaltransport_lastTempo);\n\t    this.globaltransport_tempoNeedsReset = false;\n\t    fillSignal(this.globaltransport_state, this.vs, this.globaltransport_lastState);\n\t    this.globaltransport_stateNeedsReset = false;\n\t    this.globaltransport_setupDone = true;\n\t}\n\tstackprotect_check() {\n\t    this.stackprotect_count++;\n\t\n\t    if (this.stackprotect_count > 128) {\n\t        console.log(\"STACK OVERFLOW DETECTED - stopped processing branch !\");\n\t        return true;\n\t    }\n\t\n\t    return false;\n\t}\n\tupdateTime(time) {\n\t    this._currentTime = time;\n\t    this.sampleOffsetIntoNextAudioBuffer = (rnbo_fround(this.msToSamps(time - this.getEngine().getCurrentTime(), this.sr)));\n\t\n\t    if (this.sampleOffsetIntoNextAudioBuffer >= (this.vs))\n\t        this.sampleOffsetIntoNextAudioBuffer = (this.vs) - 1;\n\t\n\t    if (this.sampleOffsetIntoNextAudioBuffer < 0)\n\t        this.sampleOffsetIntoNextAudioBuffer = 0;\n\t}\n\tassign_defaults() {}\n\tsetEngineAndPatcher(engineInterface, parentPatcher) {\n\t    this._engineInterface = engineInterface;\n\t    this._parentPatcher = parentPatcher;\n\t}\n\tgetEngine() {\n\t    return this._engineInterface;\n\t}\n\tgetPatcher() {\n\t    return this._parentPatcher;\n\t}\n\tgetTopLevelPatcher() {\n\t    return this;\n\t}\n} // end class\n\nrnboObj = new RNBOPatcher();",
      "encoding": "utf-8",
      "type": "js"
    }
  ]
}